<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport"    content="width=device-width, initial-scale=1">
<meta name="description" content="">
<meta name="author"      content="">

<meta property="og:url"         content="https://www.alfray.com/trains/arduino_nce.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Automation: Arduino NCE" />

<meta property="og:image"       content="https://www.alfray.com/trains/img_bc7eeb2e51f57817767c5154b2cf19ba0233f0b8f7558c33f64387c6d2763cbai.jpg" />

<meta name="twitter:card"        content="summary" />
<!-- meta name="twitter:site"    content="@flickr" / -->
<meta name="twitter:title"       content="Automation: Arduino NCE" />

<meta name="twitter:image"       content="https://www.alfray.com/trains/img_bc7eeb2e51f57817767c5154b2cf19ba0233f0b8f7558c33f64387c6d2763cbai.jpg" />

<title>Automation: Arduino NCE</title>

<script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5c66171070e9220011ed1c61&product=inline-share-buttons" async="async"></script>

<!-- Custom styles for this template -->
<style type="text/css">
body {
    font-family: sans-serif;
    margin: 0;
}

.main {
    margin: 8px;
}

p, span {
    line-height: 1.2;
    text-align: justify;
}

p.console {
    margin: 0;
    padding: 0;
}

.container {
    max-width: 95%;
}

@media screen and (min-width: 600px) {
    .container {
        max-width: 60rem;
    }
}

.center-horiz {
    margin: auto;
}

.no-margin-container {
}

/* Header + Title */
.blog-header {
  margin-bottom: 3rem;
  background-color: #428bca;
  box-shadow: inset 0 -.1rem .25rem rgba(0,0,0,.1);
}


.banner-bg-image {
    height: 50px;
    background-image: url("header.jpg");
    background-position: center;
    background-size: 100% auto;
}

@media screen and (min-width: 600px) {
    .banner-bg-image {
        height: 200px;
    }
}


.title-container {
    color: #fff;
    padding: 1rem;
    line-height: 1.5;
    font-weight: 500;
    font-size: 24px;
    font-family: sans-serif;
}

.title-container a {
    color: #fff;
    text-decoration: none;
}

.bottom-container {
    margin-top: 8px;
    color: #fff;
    background-color: #428bca;
    font-family: sans-serif;
    text-align: center;
    font-size: small;
    line-height: 1rem;
}

@media screen and (min-width: 600px) {
    .bottom-container {
        font-size: x-small;
    }
}

h1, h2, h3, h4, h5, h6 {
    font-family: sans-serif;
    font-weight: bold;
}

.text-hide {
    font: 0/0 a;
    color: transparent;
    text-shadow: none;
    background-color: transparent;
    border: 0;
}

td p {
    margin: 0;
}


</style>
</head>

<body>

<header class="blog-header">

    <div class="no-margin-container banner-bg-image text-hide">
        Site Banner Image
    </div>

    <div class="title-container">
        <a href="https://www.alfray.com/trains/">Ralf's Train Pages</a>
        
        /
        <a href="arduino_nce.html">Automation: Arduino NCE</a>
        
    </div>
</header>

<main role="main">
<div class="main">
<div class="container center-horiz">

<p></p>
<table style="border-collapse:collapse;border-spacing:0;margin-left:auto;margin-right:auto">
 <tbody>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="background-color:rgb(208, 224, 227);border-bottom-color:rgb(164, 194, 244);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(164, 194, 244);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(164, 194, 244);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(164, 194, 244);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:597.6pt"><p style="text-align:center"><span style="font-size:24pt;font-weight:700">Automation: Arduino and NCE</span></p></td>
  </tr>
 </tbody>
</table>
<p></p>
<p style="text-align:center"><span>2016-05</span></p>
<p></p>
<p><span>In this article, I'll explain how to control an NCE system using an Arduino. This is a follow up to an earlier article I wrote that explains the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://www.alfray.com/trains/nce_usb.html" style="color:inherit;text-decoration:inherit">inner workings of the NCE USB interface</a></span><span>.</span></p>
<p></p>
<p><span>The layout automation I had done so far involved a computer running some script driving the animation either by interfacing to JMRI or directly to NCE over USB. However, for my latest project, I did not want to have a computer running. I wanted a system driven by an Arduino that would directly control an NCE command station.</span></p>
<p></p>
<p><span>Note that here I am explicitly not interested in the Arduino providing DCC power &amp; commands to the tracks. The trains are solely controlled by the NCE command station. The Arduino operates like an NCE controller, exactly like an operator would do with an NCE ProCab.</span></p>
<p></p>
<p><span>In the past at the Randall museum in SF I used a Raspberry Pi connected to an NCE system via an </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1T0uU9H" style="color:inherit;text-decoration:inherit">NCE USB interface</a></span><span>. At home I use a similar setup but using a cheap laptop. In both cases the computers run Linux and JMRI so I can control the system using the JMRI WiThrottle protocol over wifi or via a Python script run directly via JMRI. The WiThrottle protocol allows a program to control any number of trains. The JMRI scripting in Python has the extra advantage of allowing a program to have access to any sensors, routes or blocks defined in JMRI. The downside is having to take care of a computer, which means extra maintenance and complexity. That's where Arduinos are good, in the case where you have a single fixed task. They are easy to program, quite versatile, and at the same time fairly maintenance free -- once your sketch is programmed, just power up the Arduino and it will do its job. Once done, just pull the plug, no need to deal with boot up times and shutdown procedures.</span></p>
<p></p>
<p><span>Before going into too many details, here's a small experiment I made at home that illustrates this and a few other things.</span></p>
<p><span>The first version was based around a DigiX:</span></p>
<p></p>
<p style="text-align:center"><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:376.85px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:559.50px"><img alt="" src="img_bc7eeb2e51f57817767c5154b2cf19ba0233f0b8f7558c33f64387c6d2763cbai.jpg" style="margin-left:0.00px;margin-top:0.00px" title=""></span></p>
<p style="text-align:left"></p>
<p style="text-align:left"><span>which I then updated to use an Arduino Mega and more peripherals, as can be seen on </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://www.youtube.com/watch?v=PP1nxWi8WeM" style="color:inherit;text-decoration:inherit">this video demonstration</a></span><span>:</span></p>
<p style="text-align:left"></p>
<p style="text-align:center"><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><iframe width="560" height="315" src="https://www.youtube.com/embed/PP1nxWi8WeM" frameborder="0" allowfullscreen></iframe></span></p>
<p></p>
<p><span>In this setup, we have an </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1VJl4ti" style="color:inherit;text-decoration:inherit">Arduino Mega 2560</a></span><span>&nbsp;controlling:</span></p>
<ul style="margin:0">
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>A train via an </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1T0uU9H" style="color:inherit;text-decoration:inherit">NCE USB interface</a></span><span>. </span></li>
 <ul>
  <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt;text-align:left"><span>The NCE module is connected to an </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1W7TJBF" style="color:inherit;text-decoration:inherit">NCE DCC Twin</a></span><span>&nbsp;(my command station/booster) which is of course connected to the tracks. </span></li>
 </ul>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>A 2-line LCD display via I²C (</span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1W5n3Zt" style="color:inherit;text-decoration:inherit">SainSmart I2C 2004 20x4 LCD</a></span><span>).</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>A 2-relay board to control the turnout (</span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1rsFsCl" style="color:inherit;text-decoration:inherit">SainSmart 5V 2-channel solid state relay</a></span><span>).</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>An IR reflective sensor to detect the position on the engine (</span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/26NywA3" style="color:inherit;text-decoration:inherit">TCRT5000</a></span><span>).</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>An </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1Y4rEID" style="color:inherit;text-decoration:inherit">Xmega XMiniLab</a></span><span>&nbsp;from </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://www.gabotronics.com/development-boards/xmega-xminilab.htm" style="color:inherit;text-decoration:inherit">Gabotronics</a></span><span>&nbsp;displaying the NCE serial protocol.</span></li>
</ul>
<p></p>
<p><span>The Arduino sketch used on that video is </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://bitbucket.org/model-railroad/layout-wifi/src/6e9eacca9c52db791bd04994e89732d61a6bac48/experimental/MegaAutoShunt/?at=shunt-2016-04-10" style="color:inherit;text-decoration:inherit">available here on BitBucket</a></span><span>.</span></p>
<p></p>
<p><span>Now let's see how to build this piece by piece.</span></p>
<p></p>
<h1 id="h.jif5qimqfrqp" style="padding-bottom:6pt;padding-top:20pt;page-break-after:avoid"><span style="font-size:20pt">Arduino and LCD</span></h1>
<p></p>
<p><span>This is the easiest part. Sort of. If you have never connected an LCD to an Arduino, here's a very short primer.</span></p>
<p></p>
<p><span>First, you must be aware of the "logic level" of your Arduino. Devices like the Mega or the Uno use 5V on their input/output pins. However devices like the Due or clones like the DigiX run using 3.3 V. That's a very important detail since trying to bring 5 V on the input/output pins of these devices will cause them some sort of damage. </span></p>
<p><span>How do you know which one supports what? First it's clearly written in the specifications, for example the page on the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://www.arduino.cc/en/Main/ArduinoBoardDue" style="color:inherit;text-decoration:inherit">Arduino Due</a></span><span>&nbsp;and the one on the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://digistump.com/products/50" style="color:inherit;text-decoration:inherit">Digistump DigiX</a></span><span>&nbsp;indicate this very clearly. Second, a simple rule is if the device runs with an ARM processor, it's pretty much guaranteed to be using 3.3V logic levels.</span></p>
<p></p>
<p><span>On the accessories side, an LCD like the one I used clearly indicates it requires 5V logic. Same goes for the relays board.</span></p>
<p><span>What should you do if you have for example a DigiX with 3.3V logic levels and an LCD that requires 5V? That's simple, this requires using an extra </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1Y4rukA" style="color:inherit;text-decoration:inherit">5V/3.3V logic level converter</a></span><span>&nbsp;to connect the LCD to the DigiX as I did in the first version of this experiment.</span></p>
<p></p>
<p><span>Now to continue on the primer, regarding LCD screens. There are a few form factors out there: 1 line, 2 lines, 4 lines, 10 characters wide, 20 characters wide, green or blue backlights. There are also the graphic dot matrixes ones, very convenient if you need to display curves and not just text. Now the thing is that the text displays are typically controlled by a 16-pin bus, which is of course quite inconvenient to connect to an Arduino. Instead there exist small add-on boards that allow an Arduino to drive the LCD via the 4-pin I²C bus. I²C is nothing more than a serial link. You can either buy the LCD board and the IIC/I²C board separately and solder them together or you can buy a board like the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1W5n3Zt" style="color:inherit;text-decoration:inherit">SainSmart LCD2004</a></span><span>&nbsp;that already has the add-on module on the back, which is what I did; it looks like this:</span></p>
<p></p>
<p style="text-align:center"><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:120.00px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:419.00px"><img alt="" src="img_956ec6c904ea1cf5096ce8dd958020a454fc9de4067313046d303f48e7278953i.jpg" style="margin-left:0.00px;margin-top:0.00px" title=""></span></p>
<p></p>
<p style="text-align:left"><span>Here you can see that the LCD uses an IIC (parallel data, 16-pins at the top) with an add-on "IIC/I2C" board. It features an NXP PCF8574T to convert to I²C, which spec is here: </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://www.nxp.com/documents/data_sheet/PCF8574.pdf" style="color:inherit;text-decoration:inherit">http://www.nxp.com/documents/data_sheet/PCF8574.pdf</a></span></p>
<p></p>
<p><span>The nice thing with the I²C is that it's a bus, which means several devices can share the same serial connection. Devices are identified by a 1-byte address and that address is fixed by the add-on board in this case. You need to know the address of the board, and according to the SainSmart page and the Amazon comments, it could be either 0x27 or 0x3F. How do you know which one it is for your module? It's all indicated in the spec above in figure 10: the PCF8574T will use 0x27 and the PCF8574AT will use 0x3F. On some of the IIC/I2C add-on boards, the 3 least significant bits of the address can be changed, typically default to 111 and changeable by cutting or soldering a trace on the board.</span></p>
<p></p>
<h2 id="h.x897a3ladtyy" style="padding-bottom:6pt;padding-top:18pt;page-break-after:avoid"><span style="font-size:16pt">LCD connection to Arduino Mega</span></h2>
<p><span>I'm using the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://www.arduino.cc/en/Main/ArduinoBoardMega2560" style="color:inherit;text-decoration:inherit">Arduino Mega 2560</a></span><span>. You can find the pinout here: </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://pighixxx.com/megapdf.pdf" style="color:inherit;text-decoration:inherit">http://pighixxx.com/megapdf.pdf</a></span><span>&nbsp;</span></p>
<p><span>For I²C, we need 4 pins: Ground, 5V, SDA (serial data) and SCL (serial clock).</span></p>
<p><span>My version is a Mega revision 3 and it looks like it has 2 I²C buses on the headers but that's not true: SDA is on pin 20 and SCL is on pin 21. On the pinout you may see there are also SDA and SCL pins next to AREF, but these are the same pins as 20 and 21. This Arduino has a single I²C bus.</span></p>
<p></p>
<p style="text-align:center"><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:263.22px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:668.00px"><img alt="" src="img_362a6aca41a971c7a6a678713a43f703ea1619f3b239ba5af10f52e82a88b548d.png" style="margin-left:0.00px;margin-top:0.00px" title=""></span></p>
<p></p>
<p><span>On the IIC/I²C add-on card, you'll find similar pins: Gnd, 5V, SDA, SCL. Just connect each pin to its equivalent:</span></p>
<ul style="margin:0">
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>LCD GND ⇒ Mega GND (for example just below pin 52 or 53).</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>LCD 5V ⇒ Mega 5V (for example just above pin 22 or 23).</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>LCD I²C SDA ⇒ Mega pin 20 SDA.</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>LCD I²C SCL ⇒ &nbsp;Mega pin 21 SCL.</span></li>
</ul>
<p></p>
<p><span>Now let's program the Arduino to use this. The </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://www.arduino.cc/en/Main/Software" style="color:inherit;text-decoration:inherit">Arduino IDE 1.6.5</a></span><span>&nbsp;already has the library you need to drive the LCD in IIC mode. However what we need is a small extension to drive it via the I²C bus, and this is not included in the Arduino libraries by default. There are also a few out there with confusingly all the same name.</span></p>
<p><span>I used the LiquidCrystal_I2C library provided on the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://www.sainsmart.com/sainsmart-iic-i2c-twi-serial-2004-20x4-lcd-module-shield-for-arduino-uno-mega-r3.html" style="color:inherit;text-decoration:inherit">SainSmart LCD 2004</a></span><span>&nbsp;web page: look for a link called "Download Link for LCD2004", extract the RAR and take the two LiquidCrystal_I2C files (.h and .cpp) and place them in your Arduino Sketch (I have a copy in my </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://bitbucket.org/model-railroad/layout-wifi/src/6e9eacca9c52db791bd04994e89732d61a6bac48/experimental/MegaAutoShunt/?at=shunt-2016-04-10" style="color:inherit;text-decoration:inherit">git project on BitBucket</a></span><span>).</span></p>
<p></p>
<p><span>Once we have this, driving the LCD is real easy and is done that way:</span></p>
<p></p>
<table style="border-collapse:collapse;border-spacing:0;margin-right:auto">
 <tbody>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="background-color:rgb(255, 242, 204);border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:597.6pt"><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">#include &lt;LiquidCrystal.h&gt;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">#include &lt;Wire.h&gt;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">#include "LiquidCrystal_I2C.h"</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">// set the LCD address to 0x27 for a 20 chars and 4 lines display</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">LiquidCrystal_I2C lcd(0x27, 20, 4);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void setup() {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; lcd.init();</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; lcd.display();</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; lcd.backlight();</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; lcd.setCursor(0,0);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; lcd.print("Print on line 0");</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; lcd.setCursor(1,0);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; lcd.print("Print on line 1");</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">}</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void loop() {}</span></p></td>
  </tr>
 </tbody>
</table>
<p></p>
<h2 id="h.9cdbf6o3fokp" style="padding-bottom:6pt;padding-top:18pt;page-break-after:avoid"><span style="font-size:16pt">LCD connection to a DigiX</span></h2>
<p><span>I started this way, so I'll just put this here without too many details in case it's of any use.</span></p>
<p><span>I originally started this project using a </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://digistump.com/products/50" style="color:inherit;text-decoration:inherit">DigiX</a></span><span>&nbsp;by Digistump, a Due/Mega clone with about 99 IO pins, several UARTs, a couple I²C buses, an SDCard and a Wifi module. Unfortunately it runs using 3.3V logic levels which is a problem with both the LCD and the relay board. Then in the middle of my work I unfortunately screwed up the wifi module to the point of making it inoperable. I revisited my project specs and decided I wasn't making use of the extra features so I went back to an </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1VJl4ti" style="color:inherit;text-decoration:inherit">Arduino Mega</a></span><span>, which turns out to be a much cheaper board anyway.</span></p>
<p></p>
<p><span>The DigiX uses 3.3V logic levels. There are two I²C buses, one on pins 20/21 like a Mega and the other one on pins 70/71 (SDA1, SCL1). The EEPROM is on the I²C bus on pins 20/21 so no matter what, never connect anything that provides 5V signals on these pins, as it's clearly stated that will damage it. To avoid that I used the other I²C bus on pins 70/71.</span></p>
<p></p>
<p><span>I thought about powering the LCD using 3.3V instead of the recommended 5V but that didn't work. The display was erratic and the backlight did not light up.</span></p>
<p></p>
<p><span>So instead I used </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/23nQDbc" style="color:inherit;text-decoration:inherit">this logic level shifter</a></span><span>&nbsp;(there are a bazillion to choose from, they are all the same, either called I2C logic level converter or TTL logic converter or shifter… all the same stuff</span><span>).</span></p>
<p><span>It's very simple: connect one side to the 3.3V pins of the I²C on the DigiX and the other side to the 5V pins on the LCD.</span></p>
<p></p>
<p style="text-align:center"><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:191.48px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:668.00px"><img alt="" src="img_17db5f5d9b8b9c776b575ce4e4f75a2c85359e5726a9de733246376ec6e54ef3d.png" style="margin-left:0.00px;margin-top:0.00px" title=""></span></p>
<p></p>
<p><span>Pinout details</span><span>&nbsp;from LCD/I²C &nbsp;⇒ [Level Shifter] ⇒ Digix/I²C </span></p>
<ul style="margin:0">
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>LCD GND ⇒ H GND ⇒ L GND ⇒ DigiX GND on nRF pin 1 (in front of pin 24).</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>[Level Shifter LV] ⇒ DigiX 3.3V from nRF (in front of pin 28).</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>[Level Shifter HV] ⇒ DigiX 5V next to pin 22.</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>LCD Vcc (5V) ⇒ DigiX 5V next to 23.</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>LCD SDA ⇒ [HV2 ⇒ LV2] ⇒ DigiX 70 SDA</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>LCD SCL ⇒ &nbsp;[HV1 ⇒ LV1] ⇒ DigiX 71 SCL</span></li>
</ul>
<p></p>
<table style="border-collapse:collapse;border-spacing:0;margin-right:auto">
 <tbody>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="text-align:right"><span style="vertical-align:baseline">LCD/I²C Pins</span></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="text-align:center"><span style="vertical-align:baseline">[Level Shifter] Pins</span></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p><span style="vertical-align:baseline">Digix/I²C Pins</span></p></td>
  </tr>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="text-align:right"><span style="vertical-align:baseline">LCD GND</span></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="text-align:center"><span style="vertical-align:baseline">&nbsp;⇒ [H GND ⇒ L GND] ⇒ </span></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p><span style="vertical-align:baseline">DigiX GND (e.g. nRF pin 1)</span></p></td>
  </tr>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="height:11pt;text-align:right"></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="text-align:center"><span style="color:rgb(255, 255, 255)">&nbsp;⇒ </span><span style="vertical-align:baseline">[Level Shifter LV] ⇒ </span></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p><span style="vertical-align:baseline">DigiX 3.3V (e.g. on nRF header)</span></p></td>
  </tr>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="height:11pt;text-align:right"></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="text-align:center"><span style="color:rgb(255, 255, 255)">&nbsp;⇒ </span><span style="vertical-align:baseline">[Level Shifter HV] ⇒ </span></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p><span style="vertical-align:baseline">DigiX 5V next to pin 22</span></p></td>
  </tr>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="text-align:right"><span style="vertical-align:baseline">LCD Vcc (5V)</span></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="height:11pt;text-align:center"></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p><span style="vertical-align:baseline">DigiX 5V next to 23</span></p></td>
  </tr>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="text-align:right"><span style="vertical-align:baseline">LCD SDA</span></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="text-align:center"><span style="vertical-align:baseline">&nbsp;⇒ [HV2 ⇒ LV2] ⇒ </span></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p><span style="vertical-align:baseline">DigiX 70 SDA</span></p></td>
  </tr>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="text-align:right"><span style="vertical-align:baseline">LCD SCL</span></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p style="text-align:center"><span style="vertical-align:baseline">&nbsp;⇒ [HV1 ⇒ LV1] ⇒ </span></p></td>
   <td colspan="1" rowspan="1" style="border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:199.2pt"><p><span style="vertical-align:baseline">DigiX 71 SCL</span></p></td>
  </tr>
 </tbody>
</table>
<p></p>
<p></p>
<p><span>Programming the DigiX to use the LCD uses exactly the same API as explained earlier, with the sole difference that the Digistump extension to the Arduino IDE already provides the missing LiquidCrystal_I2C library. So all you have to do is include the &lt;LiquidCrystal_I2C.h&gt; header.</span></p>
<h1 id="h.yb4pou4izxvi" style="padding-bottom:6pt;padding-top:20pt;page-break-after:avoid"><span style="font-size:20pt">Arduino and Relays</span></h1>
<p><span>Since in this demo I had a single turnout, I chose to control the Atlas twin-coil turnout directly using relays rather than using an NCE Snap-It module or using an Atlas DCC control unit.</span></p>
<p></p>
<p><span>The operation of a twin-coil turnout is fairly simple: two coils are used as magnets to pull a pin in one direction or another. The pin moves the turnout. The coils must be energized only very briefly (I used 150 ms for example) otherwise they will overheat and burn out. The power for the coils typically comes from an accessory transformer pack. Some twin-coil turnouts can be energized using AC, others DC, others both. The kind I use (either Atlas or Bachmann) seem to work better with 16 V AC.</span></p>
<p></p>
<p><span>I choose to use the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1rsFsCl" style="color:inherit;text-decoration:inherit">SainSmart 5V 2-channel solid state relay</a></span><span>. Now there are a couple things to mention about it:</span></p>
<ul style="margin:0">
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>It's a solid state relay, not mechanical, which means it's silent. </span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>The relays on the board are Omron G3MB-202P which spec can be found </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://media.digikey.com/pdf/Data%20Sheets/Omron%20PDFs/G3MB.pdf" style="color:inherit;text-decoration:inherit">here</a></span><span>.</span></li>
</ul>
<p></p>
<p><span>Now that last detail is important</span></p>
<p><span>The </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://media.digikey.com/pdf/Data%20Sheets/Omron%20PDFs/G3MB.pdf" style="color:inherit;text-decoration:inherit">Omron G3MB-202P</a></span><span>&nbsp;supposedly requires 5V in input but they work fine when the relays are powered using the 3V pin from the DigiX.</span></p>
<p><span>These however have an important limitation: the supported load in the spec is only AC. They internally use phototriacs, and a </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://en.wikipedia.org/wiki/TRIAC" style="color:inherit;text-decoration:inherit">TRIAC</a></span><span>, although designed to switch AC can also in theory switch DC, which a small catch: triacs are latching devices. Once triggered, they will only release the output (load) once the current or voltage drops under a certain level. The spec of the G3MB-202P indicates this is 1V. In an AC load, that occurs naturally with the AC cycle. In a DC load, it doesn't, which means triggering the SSR will turn on the load but it will never turn off even when the relay input is released -- and in this application that will definitely fry the coils.</span></p>
<p></p>
<p><span>So this relay board works for me because I use the 16V AC from an accessory power pack to power the Atlas twin-coils, and these SSR will properly release on AC, but they won't on DC.</span></p>
<p><span>If you need to drive your twin-coils turnouts in DC, you need a different relay, for example the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1W7ZAa4" style="color:inherit;text-decoration:inherit">SainSmart 8-CH SSR 5A DC-DC 5V-220V SSR</a></span><span>. When you get these boards, look carefully at the specs of the relays if possible. </span></p>
<p></p>
<p><span>Connection is fairly trivial, the relay can be controlled using any of the digital IO pins and the Mega has a ton of them.</span></p>
<p></p>
<p style="text-align:center"><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:227.40px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:668.00px"><img alt="" src="img_f82f0108fcc12d2868bf67a0487cbd52828d1a4b9190b33d743c5e034dc61cd8d.png" style="margin-left:0.00px;margin-top:0.00px" title=""></span></p>
<p></p>
<p><span>Please note that the Arduino is entirely separated from the AC accessory power. The solid state relays provide opto-isolation.</span></p>
<p></p>
<p><span>Controlling the relays is trivial. In this case the relays need to be triggered about 150 milliseconds to trip the twin-coil in the desired position.</span></p>
<p></p>
<table style="border-collapse:collapse;border-spacing:0;margin-right:auto">
 <tbody>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="background-color:rgb(255, 242, 204);border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:597.6pt"><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">#define RELAY1_PIN &nbsp; &nbsp; &nbsp;52</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">#define RELAY2_PIN &nbsp; &nbsp; &nbsp;53</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">#define RELAY_TIME_MS &nbsp; 150</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void setup() {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; pinMode(RELAY1_PIN, OUTPUT);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; pinMode(RELAY2_PIN, OUTPUT);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; digitalWrite(RELAY1_PIN, LOW);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; digitalWrite(RELAY2_PIN, LOW);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">}</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">// Direction: 0=Normal (PIN1), 1=Reverse (PIN2)</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void set_turnout(int direction) {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; int pin = direction ? RELAY2_PIN : RELAY1_PIN;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; digitalWrite(pin, HIGH);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; delay(RELAY_TIME_MS);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; digitalWrite(pin, LOW);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">}</span></p></td>
  </tr>
 </tbody>
</table>
<p></p>
<h1 id="h.hrkaw4rlptpc" style="padding-bottom:6pt;padding-top:20pt;page-break-after:avoid"><span style="font-size:20pt">Arduino and IR Reflective Sensor</span></h1>
<p><span>In the demonstration I made, I use an infrared-reflective sensor to detect the position of the engine at a specific place on the track. </span></p>
<p></p>
<p><span>I first used an LDR (light dependent resistor) for the task. These are commonly found on grade-crossing circuits where 4 LDRs are located, 2 on each side of the grade crossing to detect the passing trains. The common issue with LDRs is calibration as their resistance varies not only with the passing of trains but also with ambient room illumination. </span></p>
<p></p>
<p><span>Infrared sensors solve this by reacting to infrared light instead of a broader visible spectrum. A typical setup is to have a LED that emits infrared located on one side of the track and the infrared photodetector on the other side. This detects when an object cuts the infrared beam.</span></p>
<p></p>
<p><span>An infrared reflective sensor works similarly but instead the emitter and the receiver are next to each other. The receiver detects when the emitted infrared bounces off on a surface in front of the sensor. They both look like LEDs (see below) but only one is really an emitter and the other is a photodetector.</span></p>
<p></p>
<p><span>The model I chose is a </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/26NywA3" style="color:inherit;text-decoration:inherit">TCRT5000 clone</a></span><span>. You can find the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://www.vishay.com/docs/83760/tcrt5000.pdf" style="color:inherit;text-decoration:inherit">Vishay spec here</a></span><span>.</span></p>
<p><span>What you want to look for in the spec is the max current on the emitter and the ideal current on the receiver side.</span></p>
<p><span>The model I got is nothing more than 2 separate LEDs stuck together in a flimsy small plastic shell. You could easily remove the plastic shell and mount them in any way that makes sense on your layout. My idea was to have them under the track with the LEDs flush with the ties, pointing upwards.</span></p>
<p></p>
<p><span>The photodetector on the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/26NywA3" style="color:inherit;text-decoration:inherit">TCRT5000</a></span><span>&nbsp;varies its </span><span style="font-style:italic">current</span><span>&nbsp;based on the amount of light received. No light, no current; lots of light, more current. The amount of light that bounces and the collector current depends on the distance between the detector and the object. The nominal distance is 2 millimeters and experimentation showed that 5-6 mm was usable but something like 10 mm would be too much. Since the collector current is what varies and the Arduino's analog input measures voltage, we just need to place a resistor in series. And the good news is that we don't have to use an external extra resistor, we can just use the one built-in the each Arduino's analog pin: they have internal pull-up resistors.</span></p>
<p></p>
<p><span>The Arduino Mega's spec puts the internal pull-ups at 20-50 kΩ which is a good match for us.</span></p>
<p style="text-align:left"><span>In the end, t</span><span>hat's the schematics we get:</span></p>
<p style="text-align:left"></p>
<p style="text-align:center"><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:261.04px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:390.50px"><img alt="" src="img_74bfd97b969c02b07618da011b87618dbeed0dfb92e7391a13942a989040d4b9d.png" style="margin-left:0.00px;margin-top:0.00px" title=""></span><span>&nbsp;</span><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:159.00px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:98.00px"><img alt="" src="img_f80289b278d4cbe67d624ab9c88979bfbd475e6ac350076aaf877678d21b2d8di.jpg" style="margin-left:0.00px;margin-top:0.00px" title=""></span></p>
<p></p>
<p><span>That does mean that the value measured on the ADC is high when there's no infrared being received. The value lowers when we detect an object, and the amount depends on the amount of light reflected, which depends on material and distance.</span></p>
<p></p>
<p><span>Here's the Arduino sketch needed to use this:</span></p>
<p></p>
<table style="border-collapse:collapse;border-spacing:0;margin-right:auto">
 <tbody>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="background-color:rgb(255, 242, 204);border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:597.6pt"><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">#define IR0_PIN 0</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">#define IR0_THRESHOLD 700</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">int ir0_activated = 0;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void setup() {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; pinMode(A0, INPUT_PULLUP);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; digitalWrite(A0, HIGH);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">}</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void loop() {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; int a = analogRead(IR0_PIN);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; if (a &lt; IR0_THRESHOLD) {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; &nbsp; ir0_activated = 1;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; }</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; if (ir0_activated) {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; &nbsp; ir0_activated = 0;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; &nbsp; // Do something</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; }</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">}</span></p></td>
  </tr>
 </tbody>
</table>
<p></p>
<p><span>In the actual code I use a window to compute a moving average on the last 10 values. The activation boolean makes sure this is seen as a flag/toggle: once the value goes below the desired threshold, we remember that the sensor was activated and then only reset it once the sketch uses that information.</span></p>
<p></p>
<h1 id="h.w9szdh6z0wx4" style="padding-bottom:6pt;padding-top:20pt;page-break-after:avoid"><span style="font-size:20pt">Arduino and NCE USB interface</span></h1>
<p><span>Now we're getting to the most important part since this is how we're going to control our trains or accessories via DCC.</span></p>
<p></p>
<p><span>First, if you haven't read it yet, I recommend you look at my </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://www.alfray.com/trains/nce_usb.html" style="color:inherit;text-decoration:inherit">page explaining how the NCE USB interface works</a></span><span>.</span></p>
<p><span>This details the interface card and how easy it is to interface with an Arduino.</span></p>
<p></p>
<p><span>I'll give a primer here, just read the other page for all the details.</span></p>
<p></p>
<p><span>This is what the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1T0uU9H" style="color:inherit;text-decoration:inherit">NCE USB interface</a></span><span>&nbsp;looked like originally:</span></p>
<p></p>
<p><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:304.60px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:797.00px"><img alt="" src="img_5f1f4018684bb1908a9129e476b11bad24d494176e94ead3cf375f57f5084277i.jpg" style="height:454.52px;margin-left:0.00px;margin-top:-75.40px" title=""></span></p>
<p></p>
<p><span>Normally, one side plugs to a computer via USB. The other side plugs into an NCE command station via the RJ12 jack.</span></p>
<p></p>
<p><span>The board is actually powered by the USB and works like this:</span></p>
<p></p>
<p style="text-align:center"><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:152.60px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:796.80px"><img alt="" src="img_3639753a7aa5e61d24c44ac52d1b13d17770334dbab2f610c3777ce1b273ecbbd.png" style="margin-left:0.00px;margin-top:0.00px" title=""></span></p>
<p></p>
<p><span>The PC would typically run JMRI or RocRail and communicate with the board using a serial port. The USB connection is nothing more than a basic serial TTY in this case. On the board the PIC16 is the microcontroller that interprets the serial commands and communicates with the command station.</span></p>
<p></p>
<p><span>One thing to realize is that this board is nothing more than a controller without a screen and without a keypad. Think of it as an </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1VM9EVG" style="color:inherit;text-decoration:inherit">NCE ProCab</a></span><span>&nbsp;controlled by a computer instead of you. The computer sends commands following the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://ncedcc.zendesk.com/hc/en-us/article_attachments/200502169/USB_V7.pdf" style="color:inherit;text-decoration:inherit">NCE ops/command protocol</a></span><span>&nbsp;(PDF link).</span></p>
<p></p>
<p><span>What we want is obviously use this from the Arduino. One option is to use the USB port found on most Arduino, which is often also an USB to serial converter. That's a bit ironic since the Arduino uses a serial port with a CP2102 to convert that to USB, received by the NCE USB card over USB, and that card's CP2102 is transforming back the signal to serial for the PIC16 microcontroller. </span></p>
<p></p>
<p><span>The other option, which I used, is to get rid of the middle man, in this case the USB: connect the serial port from the NCE USB card directly to one of the serial ports of the Arduino. The best place to do that is by soldering 2 wires on the USB side of the optocoupler -- the small white chip in the middle of the card. By taking the serial signals on the optocoupler rather than directly on the PIC16, we benefit from isolating the Arduino from the NCE bus.</span></p>
<p></p>
<p><span>Our schema now looks like this:</span></p>
<p></p>
<p style="text-align:center"><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:327.60px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:796.80px"><img alt="" src="img_fc0582b2988eb12165095990371c255f7c563228748a98ec91dbd39829df47d3d.png" style="margin-left:0.00px;margin-top:0.00px" title=""></span></p>
<p></p>
<p><span>Rather than solder wires directly to the optocoupler going to the Arduino, I drilled 4 small holes in the board and glued a 4-pin header. The RX/TX are soldered to the D213 optocoupler and the Gnd and 5V pins are soldered to the large condenser visible nearby:</span></p>
<p></p>
<p style="text-align:center"><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:146.00px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:627.00px"><img alt="" src="img_aab47d4e9a0b5b560386ebc636ba78f7a07ea36243eaf549ea8e5f72d6e28fd7i.jpg" style="margin-left:0.00px;margin-top:0.00px" title=""></span></p>
<p></p>
<p><span>Given the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://www.mouser.com/ds/2/149/MOCD213M-116327.pdf" style="color:inherit;text-decoration:inherit">pinout of the D213 optocoupler</a></span><span>&nbsp;(PDF), here's how this is all connected:</span></p>
<ul style="margin:0">
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>D213 pin 2 ⇒ TX header pin ⇒ Mega TX1 pin 18</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>D213 pin 6 ⇒ RX header pin ⇒ Mega RX1 pin 19</span></li>
</ul>
<p></p>
<p><span>Note that the optocoupler can be powered just as well using 3.3V or 5V. And that's on the isolated side, so there's no mixup with whatever power comes from the RS485 bus (which I think is 12V anyway). So once I have my small hacked board, I can safely plug it on a Raspberry Pi, a DigiX, a Due, or any regular 5V Arduino. And since I did not cut the traces to the CP2102, I can still connect it using a regular USB cable (just don't try to use the 4-pin header at the same time!)</span></p>
<p></p>
<p><span>Below I explain how to use this, and how to debug it.</span></p>
<h2 id="h.13grivhuqmg8" style="padding-bottom:6pt;padding-top:18pt;page-break-after:avoid"><span style="font-size:16pt">NCE Protocol</span></h2>
<p><span>The NCE protocol is a fairly simple serial binary protocol: send a few bytes for a command, receive a few bytes in response, rinse and repeat. </span></p>
<p></p>
<p><span>The commands are described in detail in this </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://ncedcc.zendesk.com/hc/en-us/article_attachments/200502169/USB_V7.pdf" style="color:inherit;text-decoration:inherit">NCE documentation</a></span><span>&nbsp;(PDF download of NCE USB V7).</span></p>
<p></p>
<p><span>In my case the only commands I need are:</span></p>
<ul style="margin:0">
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>0xAA to read the software version in the PIC16. I'm not currently using it but I could use it as a comm test, and also to make sure I'm talking to the right kind of board.</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>0xA2 to control a locomotive: address, operation and parameters.</span></li>
 <ul>
  <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>I only need a handful of operations: 03 to send a reverse 128 speed, 04 for a forward 128 speed, 05 for estop reverse, 06 for e-stop forward and 07-09 for controlling functions F0..F12.</span></li>
 </ul>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>0xAD to control accessories: address, operation, parameter.</span></li>
 <ul>
  <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>Operation 3 sets the accessory in normal/on and op 4 sets it reverse/off.</span></li>
 </ul>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>0x8A and 0x9B return the status of an AIU card to read sensor data (0x8A gives both the current state and a delta change whereas 0x9B only gives the current state).</span></li>
</ul>
<p></p>
<p><span>The packet encodes the DCC engine address on 2 bytes, MSB first with 0xC0 to indicate it's a long address, e.g. engine 0113 is </span><span>0x</span><span>C0 </span><span>0x71</span><span>. To make it move forward at speed 10, send A2 C0 71 04 10 and read one byte of response, in this case ! (0x21) indicating the command was interpreted correctly.</span></p>
<p></p>
<p><span>Note that commands to set the function states operate on 4 or 5 bits at once, so for example operation 7 will set all of F0, F1, F2, F3 and F4 at the same time. Interestingly that's exactly how a ProCab controller behaves.</span></p>
<p></p>
<p><span>Anecdote: the protocol is so simple that it's also trivial to implement it as a server, for example if you happen to have your own Arduino that needs to send sensor data to JMRI. Instead of inventing a new protocol, have the Arduino behave using that protocol and configure JMRI to use either a serial or a network socket to talk to the Arduino. That's exactly what I do in the </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://bitbucket.org/model-railroad/layout-wifi" style="color:inherit;text-decoration:inherit">Translate project</a></span><span>.</span></p>
<p></p>
<p><span>Here's an extract of the Arduino sketch with some helper methods I wrote to use the protocol, and to be exact there's nothing here except sending data on a typical Arduino serial port. blink() is a small helper method that blinks the led on the arduino for debugging, omit it if you don't have your own method.</span></p>
<p></p>
<table style="border-collapse:collapse;border-spacing:0;margin-right:auto">
 <tbody>
  <tr style="height:0pt">
   <td colspan="1" rowspan="1" style="background-color:rgb(255, 242, 204);border-bottom-color:rgb(0, 0, 0);border-bottom-style:solid;border-bottom-width:1pt;border-left-color:rgb(0, 0, 0);border-left-style:solid;border-left-width:1pt;border-right-color:rgb(0, 0, 0);border-right-style:solid;border-right-width:1pt;border-top-color:rgb(0, 0, 0);border-top-style:solid;border-top-width:1pt;padding:5pt 5pt 5pt 5pt;vertical-align:top;width:597.6pt"><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">#define LOCO 113 // Alco S-2</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">#define LOCO_H (0xC0 + (LOCO &gt;&gt; 8))</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">#define LOCO_L (LOCO &amp; 0xFF)</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void setup() {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; Serial1.begin(9600 /*SERIAL_8N1*/);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">}</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">// Send an A2 command (move forward, backward, stop, control F-functions, see doc).</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void _cmd_loco_A2(int op, int data) {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; cmd_buf[0] = 0xA2;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; cmd_buf[1] = LOCO_H;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; cmd_buf[2] = LOCO_L;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; cmd_buf[3] = op;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; cmd_buf[4] = data;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; Serial1.write(cmd_buf, 5);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; blink();</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; // A2 command replies with 1 byte: ! for OK, or 1 if address is incorrect</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; lcd.setCursor(19, 1);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; if (Serial1.available()) {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; &nbsp; char c = Serial1.read();</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; &nbsp; lcd.print(c);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; }</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; blink();</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">}</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">// Turn the engine light on/off</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void cmd_light(int light_state) {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; light_state = (light_state == 1 ? 0x10 : 0);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; _cmd_loco_A2(0x07, light_state);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">}</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">// Move engine forward (&gt; 0) or backward (&lt; 0) or stop it (== 0)</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void cmd_move(int speed) {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; if (speed &lt; 0) {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; &nbsp; _cmd_loco_A2(0x01, -speed);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; } else {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; &nbsp; _cmd_loco_A2(0x02, speed);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; }</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">}</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">// send an emergency stop</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void cmd_estop() {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; _cmd_loco_A2(0x06, 0);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">}</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">// Set speed steps to 28 or 128. I think default is 128. I don't really use it.</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">void cmd_set_speed_mode(int speed_28_or_128) {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; cmd_buf[0] = 0x8D;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; cmd_buf[1] = LOCO_H;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; cmd_buf[2] = LOCO_L;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; cmd_buf[3] = speed_28_or_128 == 28 ? 2 : 3;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; Serial1.write(cmd_buf, 4);</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; blink();</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp;</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; // 8D replies with 2 bytes: ! (ok) or 1 (invalid addr) or 3 (invalid data) + speed mode 0..3</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; if (Serial1.available()) {</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; &nbsp; Serial1.read();</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; &nbsp; blink();</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; &nbsp; Serial1.read();</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; }</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">&nbsp; blink();</span></p><p class="console "><span style="font-family:&quot;Consolas&quot;;font-size:10pt;vertical-align:baseline">}</span></p></td>
  </tr>
 </tbody>
</table>
<p></p>
<h2 id="h.76ub1koxjhvt" style="padding-bottom:6pt;padding-top:18pt;page-break-after:avoid"><span style="font-size:16pt">Xminilab</span></h2>
<p><span>In the introduction image, there's a second green LCD display on my setup:</span></p>
<p></p>
<p style="text-align:center"><span style="-webkit-transform:rotate(0.00rad) translateZ(0px);border:0.00px solid #000000;display:inline-block;height:258.00px;margin:0.00px 0.00px;overflow:hidden;transform:rotate(0.00rad) translateZ(0px);width:468.00px"><img alt="" src="img_51dd71617ecd0e1223bcc65d35fd6d78d6739bc8e8461a19de037f7f8ee4c4edi.jpg" style="margin-left:0.00px;margin-top:0.00px" title=""></span></p>
<p></p>
<p><span>This is an </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://amzn.to/1Y4rEID" style="color:inherit;text-decoration:inherit">Xmega XMiniLab</a></span><span>&nbsp;from </span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="http://www.gabotronics.com/development-boards/xmega-xminilab.htm" style="color:inherit;text-decoration:inherit">Gabotronics</a></span><span>. I use it just for debugging. It's a very convenient small board that primarily acts as a basic oscilloscope and can also do voltage meter, but it comes with 2 specific features which are extremely convenient: it can display serial data from either an I²C bus or a regular serial port.</span></p>
<p></p>
<p><span>When I started on this project, at first nothing was working, and this immediately showed me I was sending the right bytes but I had RX/TX inverted so that didn't work so well. If you look carefully on the image above you can see a bunch of 0xA2 commands for the NCE.</span></p>
<p></p>
<p><span>Connection is simple:</span></p>
<ul style="margin:0">
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>Xminilab logic pin 2 ⇒ Arduino RX1 ⇒ NCE USB RX pin</span></li>
 <li style="padding-bottom:0pt;padding-left:0pt;padding-top:0pt"><span>Xminilab logic pin 3 ⇒ Arduino TX1 ⇒ NCE USB TX pin</span></li>
</ul>
<p></p>
<p><span>Then on the Xminilab use the Menu button and configure it to read serial at 9600/8/N/1.</span></p>
<p><span>Of course it's just me. Each time I work with serial ports, it happens there's a 50% chance I get RX/TX crossed at some point, a 50% chance I make the same error twice in a row and the rest I get it right the first time. So you probably don't need that kind of stuff. Unless you want one more cool gadget that people wonder what it does.</span></p>
<p></p>
<p><span>~~</span></p>
<p><span>[</span><span style="-webkit-text-decoration-skip:none;color:rgb(17, 85, 204);text-decoration:underline;text-decoration-skip-ink:none"><a href="https://www.alfray.com" style="color:inherit;text-decoration:inherit">Back to main page</a></span><span>]</span></p>
<p><span>~~</span></p>
<p></p>

</div>
</div>
</main>

<div class="sharethis-inline-share-buttons"></div>

<div class="bottom-container">&nbsp;Generated on 2025-09-01 by Rig4j 0.1-Exp-0c45755&nbsp;</div>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M1KDMEFC4D"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M1KDMEFC4D');
</script>

</body>
</html>

